a sigmoid activation makes the output value of your network to be a number between 0 and 1, is used in binary classification problem
binary_crossentropy loss, which is instead of categorical cross entropy loss, is used in binary classification problem


model = tf.keras.models.Sequential([
    # Note the input shape is the desired size of the image 300x300 with 3 bytes color
    # This is the first convolution
    tf.keras.Input(shape=(300, 300, 3)),
    tf.keras.layers.Conv2D(16, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2, 2),
    # The second convolution
    tf.keras.layers.Conv2D(32, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    # The third convolution
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    # The fourth convolution
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    # The fifth convolution
    tf.keras.layers.Conv2D(64, (3,3), activation='relu'),
    tf.keras.layers.MaxPooling2D(2,2),
    # Flatten the results to feed into a DNN
    tf.keras.layers.Flatten(),
    # 512 neuron hidden layer
    tf.keras.layers.Dense(512, activation='relu'),
    # Only 1 output neuron. It will contain a value from 0 to 1 where 0 is for 'horses' and 1 for 'humans'
    tf.keras.layers.Dense(1, activation='sigmoid')
])

train_dataset = tf.keras.utils.image_dataset_from_directory(
	TRAIN_DIR,
	image_size=(300, 300),
	batch_size=32,
	label_mode='binary'
)  # image_from_dataset_directory utility reads pictures in the source folders, converts them to tensors, and combines them with their labels to form a tf.data.Dataset. This uses the tf.data API which is optimized for parallel processing such as feeding data to GPUs and TPUs. It makes the training much faster than when using regular Numpy arrays

rescale_layer = tf.keras.layers.Rescaling(scale=1./255)  # use preprocessing -Rescaling- layers to normalize the pixel values to be in the [0, 1] range
train_dataset_scaled = train_dataset.map(lambda image, label: (rescale_layer(image), label))

image = tf.keras.utils.load_img(file, target_size=(300, 300))
image = tf.keras.utils.img_to_array(image)
image = rescale_layer(image)
image = np.expand_dims(image, axis=0)
    
prediction = model.predict(image, verbose=0)[0][0]
